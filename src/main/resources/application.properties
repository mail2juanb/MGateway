# Nom de l application
spring.application.name=mgateway

# Import de la configuration depuis le Config Server
#spring.config.import=optional:configserver:http://localhost:9101

### A AJOUTER A CONFIG-SERVER ###

# Port du serveur
server.port=9010

# Configuration Eureka
eureka.client.serviceUrl.defaultZone=http://localhost:9102/eureka/
# Pour plus tard si le service de eureka est security
# eureka.client.serviceUrl.defaultZone=http://discUser:discPassword@localhost:9102/eureka/

# RENOUVELLEMENT EUREKA
eureka.instance.leaseRenewalIntervalInSeconds=4

# Activation de la decouverte automatique des services via Eureka
spring.cloud.gateway.server.webflux.discovery.locator.enabled=true
# Permet a Spring Cloud Gateway de decouvrir automatiquement les services enregistres dans Eureka.
spring.cloud.gateway.server.webflux.discovery.locator.lower-case-service-id=true
# Normalise les noms de services en minuscules (evite les problemes de casse)

#####  CONFIGURATION DATA SOURCE MYSQL  ####
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#spring.datasource.url=jdbc:mysql://localhost:3306/userservice?serverTimezone=UTC
#spring.datasource.username=root
#spring.datasource.password=rootroot

#####  CONFIGURATION DATA SOURCE R2DBC (reactive)  ####
spring.r2dbc.url=r2dbc:mysql://localhost:3306/userservice
spring.r2dbc.username=root
spring.r2dbc.password=rootroot
# Pool de connexions (optionnel)
#spring.r2dbc.pool.enabled=true
#spring.r2dbc.pool.max-size=10
#spring.r2dbc.pool.initial-size=2

#DEFINI ENCODAGE POUR DATA.SQL
#spring.datasource.sql-script-encoding=UTF-8
# The use of configuration keys that have been renamed was found in the environment:
# Property source 'Config resource 'class path resource [application.properties]' via location 'optional:classpath:/'':
# Key: spring.datasource.sql-script-encoding
# Replacement: spring.sql.init.encoding
spring.datasource.sql.init.encoding=UTF-8

####  CONFIGURATION JPA  ####
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
spring.sql.init.mode=always
spring.jpa.defer-datasource-initialization=true

####  SPRING CLOUD SECURITY  ####
# spring.security.user.name=user
# spring.security.user.password=user
# spring.security.user.roles=ADMIN

####  CONFIG REDIS  ####
#spring.data.redis.host=localhost
#spring.data.redis.port=6379

####  SPRING CLOUD CONFIG  - Authentification aupres du service de config ####
# spring.cloud.config.username=configUser
# spring.cloud.config.password=configPassword

# controle le comportement des sessions pour les endpoints de gestion (par exemple, /actuator/health, /actuator/info, etc.)
# if_required (valeur par defaut)
#management.security.sessions=always

####  LOGS  ####
# INFO or DEBUG or WARN and more
#  Active les logs de debug pour Spring Cloud Gateway
# logging.level.org.springframework.cloud.gateway=DEBUG
#  Active les logs de debug pour Spring Security
# logging.level.org.springframework.security=DEBUG
#  Active les logs pour le filtre reactif
# logging.level.reactor.netty.http.client=DEBUG
#  Active les logs pour les requetes HTTP
# logging.level.org.springframework.web.reactive=DEBUG


####  ROUTES  ####

# Route pour le microservice clientui
spring.cloud.gateway.server.webflux.routes[0].id=clientui
spring.cloud.gateway.server.webflux.routes[0].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[0].predicates[0]=Path=/clientui/**
spring.cloud.gateway.server.webflux.routes[0].filters[0]=StripPrefix=1
# Pour conserver hote origine (pas certain que ce soit utile) :
#spring.cloud.gateway.server.webflux.routes[0].filters[1]=PreserveHostHeader
# Pour eviter de transmettre les cookies (utile pour eviter les conflits de session ou de securite) :
#spring.cloud.gateway.server.webflux.routes[0].filters[2]=RemoveRequestHeader=Cookie

# Route pour les ressources statiques (CSS, JS)
spring.cloud.gateway.server.webflux.routes[1].id=clientui-static
spring.cloud.gateway.server.webflux.routes[1].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[1].predicates[0]=Path=/webjars/**
spring.cloud.gateway.server.webflux.routes[1].filters[0]=StripPrefix=0
#spring.cloud.gateway.server.webflux.routes[1].filters[1]=PreserveHostHeader
#spring.cloud.gateway.server.webflux.routes[1].filters[2]=RemoveRequestHeader=Cookie

# Route pour le microservice Mpatient
spring.cloud.gateway.server.webflux.routes[2].id=mpatient
spring.cloud.gateway.server.webflux.routes[2].uri=lb://mpatient
spring.cloud.gateway.server.webflux.routes[2].predicates[0]=Path=/mpatient/**
spring.cloud.gateway.server.webflux.routes[2].filters[0]=StripPrefix=1
#spring.cloud.gateway.server.webflux.routes[2].filters[0]=RewritePath=/mpatient/(?<segment>.*), /$\{segment}

# Route pour l affichage de la page (Thymeleaf)
spring.cloud.gateway.server.webflux.routes[3].id=patients-ui
spring.cloud.gateway.server.webflux.routes[3].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[3].predicates[0]=Path=/patients
spring.cloud.gateway.server.webflux.routes[3].filters[0]=StripPrefix=0
#spring.cloud.gateway.server.webflux.routes[3].filters[1]=PreserveHostHeader
#spring.cloud.gateway.server.webflux.routes[3].filters[2]=RemoveRequestHeader=Cookie

# Route pour l endpoint /update/{id} vers clientui
spring.cloud.gateway.server.webflux.routes[4].id=update-ui
spring.cloud.gateway.server.webflux.routes[4].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[4].predicates[0]=Path=/update/{id}
spring.cloud.gateway.server.webflux.routes[4].filters[0]=StripPrefix=0
#spring.cloud.gateway.server.webflux.routes[4].filters[1]=PreserveHostHeader
#spring.cloud.gateway.server.webflux.routes[4].filters[2]=RemoveRequestHeader=Cookie




# Optionnel : filtre pour enlever le prefixe /api avant de router
# spring.cloud.gateway.routes[0].filters[0]=StripPrefix=1

# Exemple de routes pour Spring Cloud Gateway
# Ajoutez d autres routes si necessaire
# spring.cloud.gateway.routes[1].id=service2
# spring.cloud.gateway.routes[1].uri=lb://AUTRE-SERVICE
# spring.cloud.gateway.routes[1].predicates[0]=Path=/api/service2/**
# spring.cloud.gateway.routes[1].filters[0]=StripPrefix=1


####  DISTRIBUTED TRACING  - SPRING CLOUD SLEUTH - MICROMETER TRACING  ####

# Configuration pour chaque microservice (mgateway, clientui, mpatient)

# Configuration des endpoints Actuator
management.endpoints.web.exposure.include=health,info,metrics,prometheus,tracing

# Configuration du tracing distribue
# 100pourcent des traces (reduire en production ex : 0.1 pour 10 pourcent)
management.tracing.sampling.probability=1.0

# Configuration Zipkin
management.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans
# Ou si Zipkin est dans un container Docker :
# management.zipkin.tracing.endpoint=http://zipkin:9411/api/v2/spans

# Configuration des logs pour inclure les trace ID et span ID
logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]

# Niveaux de logs
# Pour mgateway seulement (commentez pour les autres services)
logging.level.org.springframework.cloud.gateway=DEBUG
# Pour debug le tracing (optionnel)
logging.level.io.micrometer.tracing=DEBUG