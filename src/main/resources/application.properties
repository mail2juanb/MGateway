# Nom de l'application pour l'enregistrement dans Eureka
spring.application.name=mgateway

# Port du serveur
server.port=9010

#server.address=0.0.0.0

# Configuration Eureka
# avant docker
#eureka.client.serviceUrl.defaultZone=http://localhost:9102/eureka/
# apres docker
# Configuration Eureka (utilise les variables d'environnement)
eureka.client.serviceUrl.defaultZone=http://${EUREKA_SERVER_HOST:eureka-server}:${EUREKA_SERVER_PORT:9102}/eureka/

# RENOUVELLEMENT EUREKA
eureka.instance.leaseRenewalIntervalInSeconds=4
# avec docker il faut specifier
eureka.instance.hostname=${HOSTNAME:mgateway}
eureka.instance.non-secure-port-enabled=false
eureka.instance.non-secure-port=9010
# a voir si ca pose un soucis, sinon remettre
#eureka.instance.prefer-ip-address=true
# Cela fait que par exemple dans la page web eureka,
# le lien pointe vers mgateway:9010/actuator/info et
# non l'ip : 192.168.X.XXX:9010/actuator/info


# Activation de la decouverte automatique des services via Eureka
spring.cloud.gateway.server.webflux.discovery.locator.enabled=true
# Permet a Spring Cloud Gateway de decouvrir automatiquement les services enregistres dans Eureka.
spring.cloud.gateway.server.webflux.discovery.locator.lower-case-service-id=true
# Normalise les noms de services en minuscules (evite les problemes de casse)

#####  CONFIGURATION DATA SOURCE MYSQL  ####
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#spring.datasource.url=jdbc:mysql://localhost:3306/userservice?serverTimezone=UTC
#spring.datasource.username=root
#spring.datasource.password=rootroot

# AVANT DOCKER
#####  CONFIGURATION DATA SOURCE R2DBC (reactive)  ####
#spring.r2dbc.url=r2dbc:mysql://localhost:3306/userservice
#spring.r2dbc.username=root
#spring.r2dbc.password=rootroot
# Pool de connexions (optionnel)
#spring.r2dbc.pool.enabled=true
#spring.r2dbc.pool.max-size=10
#spring.r2dbc.pool.initial-size=2
# APRES DOCKER
#####  CONFIGURATION DATA SOURCE R2DBC (reactive)  ####
spring.r2dbc.url=r2dbc:mysql://${MYSQL_GATEWAY_HOST:mysql-mgateway}:${MYSQL_GATEWAY_PORT:3306}/${MYSQL_GATEWAY_DATABASE:userservice}
spring.r2dbc.username=${MYSQL_GATEWAY_USERNAME:root}
spring.r2dbc.password=${MYSQL_GATEWAY_PASSWORD:rootroot}

#DEFINI ENCODAGE POUR DATA.SQL
#spring.datasource.sql-script-encoding=UTF-8
# The use of configuration keys that have been renamed was found in the environment:
# Property source 'Config resource 'class path resource [application.properties]' via location 'optional:classpath:/'':
# Key: spring.datasource.sql-script-encoding
# Replacement: spring.sql.init.encoding
spring.datasource.sql.init.encoding=UTF-8

####  CONFIGURATION JPA  ####
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
spring.sql.init.mode=always
spring.jpa.defer-datasource-initialization=true

####  SPRING CLOUD SECURITY  ####
# spring.security.user.name=user
# spring.security.user.password=user
# spring.security.user.roles=ADMIN

####  CONFIG REDIS  ####
#spring.data.redis.host=localhost
#spring.data.redis.port=6379

####  SPRING CLOUD CONFIG  - Authentification aupres du service de config ####
# spring.cloud.config.username=configUser
# spring.cloud.config.password=configPassword

# controle le comportement des sessions pour les endpoints de gestion (par exemple, /actuator/health, /actuator/info, etc.)
# if_required (valeur par defaut)
#management.security.sessions=always

####  LOGS  ####
# INFO or DEBUG or WARN and more
#  Active les logs de debug pour Spring Cloud Gateway
# logging.level.org.springframework.cloud.gateway=DEBUG
#  Active les logs de debug pour Spring Security
# logging.level.org.springframework.security=DEBUG
#  Active les logs pour le filtre reactif
# logging.level.reactor.netty.http.client=DEBUG
#  Active les logs pour les requetes HTTP
logging.level.org.springframework.web.reactive=DEBUG


####  ROUTES  ####

# Route pour le microservice clientui
spring.cloud.gateway.server.webflux.routes[0].id=clientui
spring.cloud.gateway.server.webflux.routes[0].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[0].predicates[0]=Path=/clientui/**
spring.cloud.gateway.server.webflux.routes[0].filters[0]=StripPrefix=1
# Pour conserver hote origine (pas certain que ce soit utile) :
#spring.cloud.gateway.server.webflux.routes[0].filters[1]=PreserveHostHeader
# Pour eviter de transmettre les cookies (utile pour eviter les conflits de session ou de securite) :
#spring.cloud.gateway.server.webflux.routes[0].filters[2]=RemoveRequestHeader=Cookie

# Route pour les ressources statiques (CSS, JS)
#fantome, il faut renumeroter
#spring.cloud.gateway.server.webflux.routes[1].id=fantome
#spring.cloud.gateway.server.webflux.routes[1].uri=lb://fantome
#spring.cloud.gateway.server.webflux.routes[1].predicates[0]=Path=/fantome/**
#spring.cloud.gateway.server.webflux.routes[1].id=clientui-static
#spring.cloud.gateway.server.webflux.routes[1].uri=lb://clientui
#spring.cloud.gateway.server.webflux.routes[1].predicates[0]=Path=/webjars/**
#spring.cloud.gateway.server.webflux.routes[1].filters[0]=StripPrefix=0
#spring.cloud.gateway.server.webflux.routes[1].filters[1]=PreserveHostHeader
#spring.cloud.gateway.server.webflux.routes[1].filters[2]=RemoveRequestHeader=Cookie

# Route pour le microservice Mpatient
spring.cloud.gateway.server.webflux.routes[1].id=mpatient
spring.cloud.gateway.server.webflux.routes[1].uri=lb://mpatient
spring.cloud.gateway.server.webflux.routes[1].predicates[0]=Path=/mpatient/**
spring.cloud.gateway.server.webflux.routes[1].filters[0]=StripPrefix=1
#spring.cloud.gateway.server.webflux.routes[1].filters[0]=RewritePath=/mpatient/(?<segment>.*), /$\{segment}

# Route pour l affichage de la page (Thymeleaf)
spring.cloud.gateway.server.webflux.routes[2].id=patients-ui
spring.cloud.gateway.server.webflux.routes[2].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[2].predicates[0]=Path=/patients
spring.cloud.gateway.server.webflux.routes[2].filters[0]=StripPrefix=0
# necessary, otherwise during a POST request, the headers are cleared and authentication is triggered
spring.cloud.gateway.server.webflux.routes[2].filters[1]=PreserveHostHeader
#spring.cloud.gateway.server.webflux.routes[2].filters[2]=RemoveRequestHeader=Cookie

# Route pour l endpoint /update/{id} vers clientui
spring.cloud.gateway.server.webflux.routes[3].id=update-ui
spring.cloud.gateway.server.webflux.routes[3].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[3].predicates[0]=Path=/update/**
spring.cloud.gateway.server.webflux.routes[3].filters[0]=StripPrefix=0
# necessary, otherwise during a POST request, the headers are cleared and authentication is triggered
spring.cloud.gateway.server.webflux.routes[3].filters[1]=PreserveHostHeader
#spring.cloud.gateway.server.webflux.routes[3].filters[2]=RemoveRequestHeader=Cookie

# Route pour le microservice Mnotes
spring.cloud.gateway.server.webflux.routes[4].id=mnotes
spring.cloud.gateway.server.webflux.routes[4].uri=lb://mnotes
spring.cloud.gateway.server.webflux.routes[4].predicates[0]=Path=/mnotes/**
spring.cloud.gateway.server.webflux.routes[4].filters[0]=StripPrefix=1

# Route pour l endpoint /add vers clientui
spring.cloud.gateway.server.webflux.routes[5].id=add-ui
spring.cloud.gateway.server.webflux.routes[5].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[5].predicates[0]=Path=/add/**
spring.cloud.gateway.server.webflux.routes[5].filters[0]=StripPrefix=0
# necessary, otherwise during a POST request, the headers are cleared and authentication is triggered
spring.cloud.gateway.server.webflux.routes[5].filters[1]=PreserveHostHeader
#spring.cloud.gateway.server.webflux.routes[5].filters[2]=RemoveRequestHeader=Cookie

# Route pour le microservice Mrisk
spring.cloud.gateway.server.webflux.routes[6].id=mrisk
spring.cloud.gateway.server.webflux.routes[6].uri=lb://mrisk
spring.cloud.gateway.server.webflux.routes[6].predicates[0]=Path=/mrisk/**
spring.cloud.gateway.server.webflux.routes[6].filters[0]=StripPrefix=1

# Route pour les ressources statiques (CSS, JS)
spring.cloud.gateway.server.webflux.routes[7].id=webjars
spring.cloud.gateway.server.webflux.routes[7].uri=lb://clientui
spring.cloud.gateway.server.webflux.routes[7].predicates[0]=Path=/webjars/**
spring.cloud.gateway.server.webflux.routes[7].filters[0]=StripPrefix=0



# Optionnel : filtre pour enlever le prefixe /api avant de router
# spring.cloud.gateway.routes[0].filters[0]=StripPrefix=1

# Exemple de routes pour Spring Cloud Gateway
# Ajoutez d autres routes si necessaire
# spring.cloud.gateway.routes[1].id=service2
# spring.cloud.gateway.routes[1].uri=lb://AUTRE-SERVICE
# spring.cloud.gateway.routes[1].predicates[0]=Path=/api/service2/**
# spring.cloud.gateway.routes[1].filters[0]=StripPrefix=1


####  DISTRIBUTED TRACING  - SPRING CLOUD SLEUTH - MICROMETER TRACING  ####

# Configuration pour chaque microservice

# Configuration des endpoints Actuator
management.endpoints.web.exposure.include=health,info,metrics,beans

# Activation de Micrometer Tracing
management.tracing.enabled=true

# Configuration du tracing distribue
# 100pourcent des traces (reduire en production ex : 0.1 pour 10 pourcent)
management.tracing.sampling.probability=1.0

# Configuration Zipkin
# avant docker
# management.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans
# Ou si Zipkin est dans un container Docker :
# management.zipkin.tracing.endpoint=http://zipkin:9411/api/v2/spans
# apres docker
management.zipkin.tracing.endpoint=http://${ZIPKIN_SERVER_HOST:zipkin}:9411/api/v2/spans

# Propagation des en-tetes B3 dans Spring Cloud Gateway
spring.cloud.gateway.default-filters[0].name=PreserveHostHeader
spring.cloud.gateway.default-filters[1].name=AddRequestHeader=X-B3-TraceId,{traceId}
spring.cloud.gateway.default-filters[2].name=AddRequestHeader=X-B3-SpanId,{spanId}

# Configuration des logs pour inclure les trace ID et span ID
logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]

# Niveaux de logs
# Pour mgateway seulement (commentez pour les autres services)
logging.level.org.springframework.cloud.gateway=DEBUG
# Pour debug le tracing (optionnel)
logging.level.io.micrometer.tracing=DEBUG

#  INFO APP  ####
#info.app.version=mgateway - Version en cours de developpement
#info.app.description=mgateway - MicroDiab, application d'analyse du diabete des patients
#info.app.documentation=mgateway - Lien vers la documentation de l'application
#info.app.information=mgateway - Informations utiles

info.app.version=mgateway - Version under development
info.app.description=mgateway - MicroDiab, diabetes analysis application for patients
#info.app.documentation.swagger=http://localhost:9010/swagger-ui/index.html
info.app.documentation.javadoc=${JAVADOC_URL:http://localhost:9010/apidocs/index.html}


# Desactive les logs DEBUG pour RouteDefinitionRouteLocator
logging.level.org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator=INFO
# Desactive les logs DEBUG pour GatewayMetricsFilter
logging.level.org.springframework.cloud.gateway.filter.GatewayMetricsFilter=INFO

#Les ressources statiques ne doivent JAMAIS traverser la chaine d authentification.
#spring.webflux.static-path-pattern=/webjars/**
# Cette propriete est inutile dans un gateway et peut causer des conflits.
# Elle doit etre definie uniquement dans clientui si necessaire.